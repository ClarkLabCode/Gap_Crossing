% Uses the user-made skeleton to create the masks for the compartments

function WS = SkeletonToCompMasks(WS)

% Port in the relevant fields from WS
NumGaps = WS.NumGaps;
NumCorridors = WS.NumCorridors;
Skeleton_x = WS.Skeleton_x;
Skeleton_y = WS.Skeleton_y;
NumComps = 3*NumGaps+1;

% CompMask is the final cell array that contains all masks of interest
% Mask1 is for odd flips and Mask2 is for even flips
CompMask1 = cell(1, NumComps);
CompMask2 = cell(1, NumComps);

% tempCentCorrMask is the cell array that is used as an intermediate to
% label the central parts of each corridor
tempCentCorrMask1 = cell(1, NumCorridors);
tempCentCorrMask2 = cell(1, NumCorridors);

% tempGapMask is the cell array that is used as an intermediate to label
% the gap parts of each corridor
tempGapMask1 = cell(1, NumGaps);
tempGapMask2 = cell(1, NumGaps);

% The way the final masks are computed from the skeleton is as follows:
% First, determine a rectangle surrounding the central region of each corridor
% Then, determine rectangles surrounding each gap for all corridors
% Then, perform a series of dilations and logical operations on these masks
% to determine all desired compartments

% Finding the central rectangle for each corridor
for corrCounter = 1:NumCorridors
    tempCentCorrMask1{corrCounter} = ...
        imdilate(...
                 poly2mask([...
                            Skeleton_x(1,1,corrCounter),...
                            Skeleton_x(4*NumGaps+2,1,corrCounter),...
                            Skeleton_x(4*NumGaps+3,1,corrCounter),...
                            Skeleton_x(4*(2*NumGaps)+4,1,corrCounter),...
                            Skeleton_x(1,1,corrCounter)...
                           ],...
                           [...
                            Skeleton_y(1,1,corrCounter),...
                            Skeleton_y(4*NumGaps+2,1,corrCounter),...
                            Skeleton_y(4*NumGaps+3,1,corrCounter),...
                            Skeleton_y(4*(2*NumGaps)+4,1,corrCounter),...
                            Skeleton_y(1,1,corrCounter)...
                           ],...
                            1080,1920),...
                 ones(9)); 
    tempCentCorrMask2{corrCounter} = ...
        imdilate(...
                 poly2mask([...
                            Skeleton_x(1,2,corrCounter),...
                            Skeleton_x(4*NumGaps+2,2,corrCounter),...
                            Skeleton_x(4*NumGaps+3,2,corrCounter),...
                            Skeleton_x(4*(2*NumGaps)+4,2,corrCounter),...
                            Skeleton_x(1,2,corrCounter)...
                           ],...
                           [...
                            Skeleton_y(1,2,corrCounter),...
                            Skeleton_y(4*NumGaps+2,2,corrCounter),...
                            Skeleton_y(4*NumGaps+3,2,corrCounter),...
                            Skeleton_y(4*(2*NumGaps)+4,2,corrCounter),...
                            Skeleton_y(1,2,corrCounter)...
                           ],...
                            1080,1920),...
                 ones(9)); 
end

% Finding the rectangles surrounding the gaps
for gapCounter = 1:NumGaps
    tempGapMask1{gapCounter} = ...
        imdilate(...
                 poly2mask([...
                            Skeleton_x(4*(gapCounter-1)+3,1,1),...
                            Skeleton_x(4*(gapCounter-1)+4,1,1)...
                            Skeleton_x(4*(2*NumGaps-gapCounter)+5,1,NumCorridors),...
                            Skeleton_x(4*(2*NumGaps-gapCounter)+6,1,NumCorridors),...
                            Skeleton_x(4*(gapCounter-1)+3,1,1)...
                           ],...
                           [...
                            Skeleton_y(4*(gapCounter-1)+3,1,1),...
                            Skeleton_y(4*(gapCounter-1)+4,1,1)...
                            Skeleton_y(4*(2*NumGaps-gapCounter)+5,1,NumCorridors),...
                            Skeleton_y(4*(2*NumGaps-gapCounter)+6,1,NumCorridors),...
                            Skeleton_y(4*(gapCounter-1)+3,1,1)...
                           ],...
                            1080,1920),...
                 ones(9)); 
    tempGapMask2{gapCounter} = ...
        imdilate(...
                 poly2mask([...
                            Skeleton_x(4*(gapCounter-1)+3,2,1),...
                            Skeleton_x(4*(gapCounter-1)+4,2,1)...
                            Skeleton_x(4*(2*NumGaps-gapCounter)+5,2,NumCorridors),...
                            Skeleton_x(4*(2*NumGaps-gapCounter)+6,2,NumCorridors),...
                            Skeleton_x(4*(gapCounter-1)+3,2,1)...
                           ],...
                           [...
                            Skeleton_y(4*(gapCounter-1)+3,2,1),...
                            Skeleton_y(4*(gapCounter-1)+4,2,1)...
                            Skeleton_y(4*(2*NumGaps-gapCounter)+5,2,NumCorridors),...
                            Skeleton_y(4*(2*NumGaps-gapCounter)+6,2,NumCorridors),...
                            Skeleton_y(4*(gapCounter-1)+3,2,1)...
                           ],...
                            1080,1920),...
                 ones(9)); 
end

% Defining some other cell arrays that are used to compute the comps
% Doing it this way ensures the full tiling of space in the video and also
% minimizes the amount of user inputs required substantially
tempAntiGapMask1 = cell(1, NumGaps+1);
tempAntiGapMask2 = cell(1, NumGaps+1);
AntiGapMask1 = cell(1, NumGaps+1);
AntiGapMask2 = cell(1, NumGaps+1);
GapMask1 = cell(1, NumGaps);
GapMask2 = cell(1, NumGaps);
tempAntiMask1 = true(size(tempGapMask1{1},1),size(tempGapMask1{1},2));
tempAntiMask2 = true(size(tempGapMask2{1},1),size(tempGapMask1{1},2));
tempVertCentMask1 = false(size(tempGapMask1{1},1),size(tempGapMask1{1},2));
tempVertCentMask2 = false(size(tempGapMask2{1},1),size(tempGapMask1{1},2));

% tempAnitMask is a single logical array that is 1 everywhere except in the
% regions that the user identified gaps
for gapCounter = 1:NumGaps
    tempAntiMask1 = logical(tempAntiMask1-tempGapMask1{gapCounter});
    tempAntiMask2 = logical(tempAntiMask2-tempGapMask2{gapCounter});
end

% tempVertCentMask is a single logical array that is 1 only in the regions that
% the user identified as being the centers of each corridor
for corrCounter = 1:NumCorridors
    tempVertCentMask1 = logical(tempVertCentMask1+tempCentCorrMask1{corrCounter});
    tempVertCentMask2 = logical(tempVertCentMask1+tempCentCorrMask2{corrCounter});
end

% NonGapMask is a single logical array that is 1 only in the regions that
% the user identified as being in the center of each corridor but not
% within a gap
NonGapMask1 = logical(tempVertCentMask1.*tempAntiMask1);
NonGapMask2 = logical(tempVertCentMask2.*tempAntiMask2);

% Finding the parts of the corridors that aren't surrounding gaps
for gapCounter = 1:(NumGaps+1)
    tempAntiGapMask1{gapCounter} = ...
        poly2mask([...
                   Skeleton_x(4*(gapCounter-1)+1,1,1),...
                   Skeleton_x(4*(gapCounter-1)+2,1,1),...
                   Skeleton_x(4*(2*NumGaps-gapCounter)+7,1,NumCorridors),...
                   Skeleton_x(4*(2*NumGaps-gapCounter)+8,1,NumCorridors),...
                   Skeleton_x(4*(gapCounter-1)+1,1,1)...
                  ],...
                  [...
                   Skeleton_y(4*(gapCounter-1)+1,1,1),...
                   Skeleton_y(4*(gapCounter-1)+2,1,1),...
                   Skeleton_y(4*(2*NumGaps-gapCounter)+7,1,NumCorridors),...
                   Skeleton_y(4*(2*NumGaps-gapCounter)+8,1,NumCorridors),...
                   Skeleton_y(4*(gapCounter-1)+1,1,1)...
                  ],...
                  1080,1920);
    tempAntiGapMask2{gapCounter} = ...
        poly2mask([...
                   Skeleton_x(4*(gapCounter-1)+1,2,1),...
                   Skeleton_x(4*(gapCounter-1)+2,2,1),...
                   Skeleton_x(4*(2*NumGaps-gapCounter)+7,2,NumCorridors),...
                   Skeleton_x(4*(2*NumGaps-gapCounter)+8,2,NumCorridors),...
                   Skeleton_x(4*(gapCounter-1)+1,2,1)...
                  ],...
                  [...
                   Skeleton_y(4*(gapCounter-1)+1,2,1),...
                   Skeleton_y(4*(gapCounter-1)+2,2,1),...
                   Skeleton_y(4*(2*NumGaps-gapCounter)+7,2,NumCorridors),...
                   Skeleton_y(4*(2*NumGaps-gapCounter)+8,2,NumCorridors),...
                   Skeleton_y(4*(gapCounter-1)+1,2,1)...
                  ],...
                  1080,1920);
end

% AntiGapMask is a cell array that contains the mask corresponding to each
% non-gap region of the corridors
% e.g. AntiGapMask{1} is the mask corresponding to the region of all the
% corridors that is above or below (depending on orientation) the 2.5mm gap
% and AntiGapMask{2} is the mask corresponding to the region of all the
% corridors that is between the 2.5mm and 3mm gaps
for gapCounter = 1:(NumGaps+1)
    AntiGapMask1{gapCounter} = logical(tempAntiGapMask1{gapCounter}.*NonGapMask1);
    AntiGapMask2{gapCounter} = logical(tempAntiGapMask2{gapCounter}.*NonGapMask2);
end

% Gap Mask is a cell array that contains the mask corresponding to each gap
% region of the corridors, excluding the wells
% e.g. GapMask{1} is the mask corresponding to the region of all the
% corridors that contrains the 2.5mm gap but not the wells
for gapCounter = 1:NumGaps
    GapMask1{gapCounter} = logical(tempVertCentMask1.*tempGapMask1{gapCounter});
    GapMask2{gapCounter} = logical(tempVertCentMask2.*tempGapMask2{gapCounter});
end

% Define cell array that will hold the well masks
WellMask1 = cell(1, NumGaps);
WellMask2 = cell(1, NumGaps);

% WellMask is a cell array that contains the mask corresponding to only the
% wells within each gap region of the corridors
% e.g. WellMask{1} is the mask corresponding to the region of all the
% corridors that contains only the wells of the 2.5mm gap
for gapCounter = 1:NumGaps
    WellMask1{gapCounter} = logical(tempGapMask1{gapCounter} - GapMask1{gapCounter});
    WellMask2{gapCounter} = logical(tempGapMask2{gapCounter} - GapMask2{gapCounter});
end

% Now that we have all the necessary masks, fill up CompMask1/2
% This uses the compartment labeling scheme of 1 to 2*NumGaps+1 for the
% central parts of the corridors, then 2*NumGaps+2 to 3*NumGaps+1 for the
% well parts of the corridors
for gapCounter = 1:(NumGaps+1)
    CompMask1{2*gapCounter-1} = AntiGapMask1{gapCounter};
    CompMask2{2*gapCounter-1} = AntiGapMask2{gapCounter};
end

% Filling in the final masks to the correct entries of CompMask
for gapCounter = 1:NumGaps
    CompMask1{2*gapCounter} = GapMask1{gapCounter};
    CompMask2{2*gapCounter} = GapMask2{gapCounter};
    CompMask1{gapCounter+2*NumGaps+1} = WellMask1{gapCounter};
    CompMask2{gapCounter+2*NumGaps+1} = WellMask2{gapCounter};
end

% Update the fields in WS
WS.CompMask1        = CompMask1;
WS.CompMask2        = CompMask2;
WS.NumComps         = NumComps;

end
